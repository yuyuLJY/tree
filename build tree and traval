#include <stdio.h>
#include <stdlib.h>
#define NullInput '0'
#define maxSize 20
//typedef int *element1;//指针类型的变量，队列里边存储的是指针
typedef enum{Link = 0,Thread = 1}PointTag;
typedef struct treenode *ptrTotreenode;
typedef ptrTotreenode tree;
//二叉树结点的结构
typedef char element2;
struct treenode
{
    element2 data;
    struct treenode *lchild;
    struct treenode *rchild;
    int ltag,rtag;//没有使用也可以放在结构体内
};
typedef struct treenode *tree;

typedef struct QNode *PtrToQNode;
typedef int position ;
typedef tree element1;//!!!!好好理解！！
struct QNode{
    element1 data1[maxSize];//存储元素的数组,数组里边放的全部都是指针
    position front,rear;//队列的头尾指针
};
typedef PtrToQNode queue;//没有*不行？？？
//把队列的名字叫做queue


queue CreatQueue();
void addQ(queue Q,element1 x);
int isEmpety(queue Q);
element1 deleteQ(queue Q);
int Isfull(queue Q);
tree creatTree1();//层序遍历创建树
void preOrderTraversal(tree t);//先序遍历，打印
void MiddleTraversal(tree BT);//中序遍历，打印输出
void PostTraversal(tree BT);
void layerTraversal(tree BT);//层序遍历，打印
void InpreOrderTraversal(tree BT);//
void InmiddleTraversal(tree BT);//非递归算法的中序遍历
void creatMiddleTree(tree BT);//创建中序线索二叉树
tree addHead(tree BT);//添加了head的二叉树
void middleTreetravalByMiddle(tree head);//中序访问中序线索二叉树
int main()
{
    tree BT,head;
    //BT=(tree)malloc(sizeof(struct treenode));
    //BT=tree creatTree1();//!!!你在干嘛！！
    BT=creatTree1();
    printf("先序遍历:");
    preOrderTraversal(BT);
    printf("\n");
    printf("中序遍历:");
    MiddleTraversal(BT);
    printf("\n");
    printf("后序遍历:");
    PostTraversal(BT);
    printf("\n");
    printf("层序遍历:");
    layerTraversal(BT);
    printf("\n");
    printf("非递归先序遍历:");
    InpreOrderTraversal(BT);
    printf("\n");
    printf("非递归中序遍历:");
    //InmiddleTraversal(BT);
    printf("\n");
    printf("打印出二叉树变成线索二叉树需要增添的连接:\n");
    head=addHead(BT);//添加了head的二叉树
    printf("线索二叉树中序遍历:");
    middleTreetravalByMiddle(head);//中序访问中序线索二叉树
    printf("\n");
    return 0;
}

//创建空队列
queue CreatQueue(){
    queue Q=(queue)malloc((sizeof(struct QNode)));
    //Q->data=(element *)malloc(maxSize*sizeof(element));//???
    Q->front=Q->rear=0;
    //Q->maxSize=maxSize;
    return Q;
}

//列队是不是满的
int Isfull(queue Q){
    if((Q->rear+1)%maxSize==Q->front)
        return 1;
    else
        return 0;
}

//添加新队列
void addQ(queue Q,element1 x){
    /*printf("\n");
    printf("rear:%d\n",Q->rear);
    printf("front:%d\n",Q->front);*/
    if(Isfull(Q)){
        printf("列队满");
        exit(0);
    }else{
        Q->rear=(Q->rear+1)%maxSize;
        Q->data1[Q->rear]=x;
        //printf("进来一个元素\n");
    }
    /*printf("rear:%d\n",Q->rear);
    printf("front:%d\n",Q->front);
    printf("本次添加结束\n");
     printf("\n");*/
}

//判断队列是否为空
int isEmpety(queue Q){
    if(Q->front==Q->rear){
        //printf("队列空了");
        return 1;
    }
    else{
        //printf("队列不空");
        return 0;
    }

}

//删除队列中的元素,返回弹出的地址
element1 deleteQ(queue Q){
    /*printf("\n");
    printf("rear:%d\n",Q->rear);
    printf("front:%d\n",Q->front);*/
    if(isEmpety(Q)){
        printf("队列空");
        exit(0);
    }else{
    //printf("出去一个元素\n");
    Q->front=(Q->front+1)%(maxSize);//删掉前的地址
    return Q->data1[Q->front];//返回的是一个队列里的元素，即一个地址
    /*printf("\n");
    printf("rear:%d\n",Q->rear);
    printf("front:%d\n",Q->front);*/
    }

}


//使用层序遍历构建树
tree creatTree1(){
    tree BT,T;//构造头结点
    element2 data;
    queue Q=CreatQueue();//创建一个空的队列

    FILE *fp;
    if((fp=fopen("E://数据结构//实验2//text.txt","r"))==NULL){
        printf("fail to open");
        exit(0);
    }

    fscanf(fp,"%c\n",&data);
    //printf("我被执行啦hhh");可以被执行
    //printf("%c",data);
    //判断是否真的有是在创建一棵树
    if(data!=NullInput){
        BT=(tree)malloc(sizeof(struct treenode));
        BT->data=data;//把读入的信息写进头结点的data域
        BT->lchild=BT->rchild=NULL;//左右儿子先搁置着NULL
        addQ(Q,BT);//把BT放入新创建的Q队列里
    }else
    return NULL;
    //队列不空就一直做执行
    while(!isEmpety(Q)){//写成了if，！！检查了好久
        T=deleteQ(Q);

        //为左儿子申请空间
        T->lchild=(tree)malloc(sizeof(struct treenode));
        fscanf(fp,"%c\n",&data);//读入左儿子的数据
        if(data!=NullInput){
        T->lchild->lchild=T->lchild->rchild=NULL;//左儿子的左儿子和右儿子
        T->lchild->data=data;
        addQ(Q,T->lchild);//
        }else T->lchild=NULL;

        //为右儿子申请空间
        T->rchild=(tree)malloc(sizeof(struct treenode));
        fscanf(fp,"%c\n",&data);//读入右儿子的数据
        if(data!=NullInput){
        T->rchild->lchild=T->rchild->rchild=NULL;
        T->rchild->data=data;
        addQ(Q,T->rchild);
        }else T->rchild=NULL;
    }
    return BT;
}

//先序遍历，打印
void preOrderTraversal(tree BT){
    if(BT){
        printf("%c",BT->data);
        preOrderTraversal(BT->lchild);
        preOrderTraversal(BT->rchild);
    }
}

//中序遍历，打印
void MiddleTraversal(tree BT){
    //printf("我被执行啦");
    //printf("%d",t->data);
    if(BT){
        MiddleTraversal(BT->lchild);//preOrderTraversal(BT->lchild);
        printf("%c",BT->data);
        MiddleTraversal(BT->rchild);
    }
}
//后序遍历，打印
void PostTraversal(tree BT){
    //printf("我被执行啦");
    //printf("%d",t->data);
    if(BT){
        PostTraversal(BT->lchild);
        PostTraversal(BT->rchild);
        printf("%c",BT->data);
    }
}

//层序遍历打印二叉树
void layerTraversal(tree BT){
    tree T;
    queue Q =CreatQueue();
    addQ(Q,BT);//先把头结点放进去
    //把队列里边的元素都打印出来
    while(!isEmpety(Q)){
        T=deleteQ(Q);
        printf("%c",T->data);//打印出这个地址的数据data信息
        if(T->lchild) addQ(Q,T->lchild);
        if(T->rchild) addQ(Q,T->rchild);
    }
}

//非递归算法的先序遍历
void InpreOrderTraversal(tree BT){
    tree T=BT;
    queue Q =CreatQueue();
    //addQ(Q,BT);//先把头结点放进去
    //开始的时候不要放进结点
    while(!isEmpety(Q)||T){
      //一直把左边的压进队列
       while(T){
            addQ(Q,T);
            T=T->lchild;
            //printf("a");
            //printf("%c",T->data);
       }
       if(!isEmpety(Q)){
        T=deleteQ(Q);
        printf("%c",T->data);
        T=T->rchild;
       }
    }
}

//!!需要修改！！
//非递归算法的中序遍历
void InmiddleTraversal(tree BT){
    tree T=BT;
    queue Q =CreatQueue();
    //addQ(Q,BT);//先把头结点放进去
    //开始的时候不要放进结点
    while(!isEmpety(Q)||T){
      //一直把左边的压进队列
       while(T){
            addQ(Q,T);
            //printf("%c",T->data);
            T=T->lchild;
            //printf("a");
            //printf("%c",T->data);
       }
       if(!isEmpety(Q)){
        T=deleteQ(Q);
        //printf("%c",T->data);
        T=T->rchild;
       }
    }
}

/*给树创建一个头节点head
先把BT这棵树线索化了，再去考虑添加头结点
*/
tree pre=NULL;

//把头结点加上，顺道调用线索二叉树
tree addHead(tree BT){
  tree head;//要申请一个空间啊！！
  head=(tree)malloc(sizeof(struct treenode));
  if(!head){
    printf("申请不成功");
    exit(0);//没有申请成功跳出来
  }
  head->rchild=head;//右指针回指
  head->rtag=1;
  head->data='#';
  if(!BT)
    head->lchild=head;//左指针指向根节点
  else{
     head->lchild=BT;//左指针指向根节点
     pre=head;//全局变量的前驱指针指向head
     creatMiddleTree(BT);
     pre->rchild=head;
     pre->rtag=Thread;
     head->rchild=pre;
  }
  return head;
}

//创建中序线索二叉树，无头结点
void creatMiddleTree(tree BT){
    tree F;
  if(BT != NULL)
    {
        creatMiddleTree(BT->lchild);
        if(BT->lchild == NULL)
        {
            F=BT;
            BT->lchild = pre; //如果该节点没有左孩子，则将该节点的左指针指向其中序前驱
            printf("%c左儿子连接到%c\n",F->data,pre->data);
            BT->ltag = Thread;//要连接的是1
        }else{
            BT->ltag = Link;
        }
        //如果该节点没有右儿子的时候
        if (pre != NULL && pre->rchild == NULL)
        {
            F=pre;
            pre->rchild = BT;
            //现在的BT是pre的后继结点，因为调用是从根开始的，一直剥到叶子
            printf("%c右儿子连接到%c\n",F->data,BT->data);
            pre->rtag = Thread;
        }
        pre = BT;
        //if (pre->rchild == NULL && pre->rtag == Link)
        if (pre->rchild == NULL )
            //因为不是创建的时候已经全部默认为链接故可以不用
        {
            pre->rtag = Thread;
        }
        creatMiddleTree(BT->rchild);
    }
}

//中序访问中序线索二叉树
void middleTreetravalByMiddle(tree head){
    tree p=head->lchild;//p指向根节点
    while(p!=head){//书遍历完会使p==NULL
        //printf("%d",p->ltag);无存储内容
        while(p->ltag==Link){
            p=p->lchild;
        }
        //printf("我被执行啦");
        printf("%c",p->data);
        while(p->rtag==Thread && p->rchild!=head){
            p=p->rchild;
            printf("%c",p->data);
        }
        p=p->rchild;
    }
}







